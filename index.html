  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pocket Option Prediction Bot</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f8fafc; color: #111; margin: 0; padding: 20px; }
    h1 { color: #007a6a; text-align: center; }
    .section { background: #fff; padding: 20px; margin: 15px auto; border-radius: 10px; max-width: 800px; box-shadow: 0 0 8px rgba(0,0,0,0.1); }
    select, button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc; margin: 6px 0; }
    button { background: #007a6a; color: #fff; border: none; cursor: pointer; transition: background 0.2s; }
    button:hover { background: #009f8a; }
    #chart { height:300px; margin-top:10px; }
    #prediction { font-size: 18px; font-weight: bold; margin-top: 10px; }
    .result { text-align: center; margin-top: 10px; }
    .pred-badge { display: inline-block; padding: 6px 12px; border-radius: 6px; }
    .up { background: #2ecc71; color: #fff; }
    .down { background: #e74c3c; color: #fff; }
    .loading { text-align: center; color: #007a6a; font-weight: bold; animation: blink 1.5s infinite; }
    @keyframes blink { 50% { opacity: 0.4; } }
    canvas { display: block; margin: 10px auto; background: #000; border-radius: 10px; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>

  <h1>Pocket Option Prediction Bot</h1>

  <div class="section">
    <h2>Market Selection</h2>
    <select id="symbol">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="BTCUSD">Bitcoin (BTC/USD)</option>
    </select>
    <button id="fetchData">Get Prediction</button>

    <div id="chart"></div>

    <div class="result">
      <div id="prediction">Waiting for data...</div>
      <div id="explain"></div>
    </div>
  </div>

  <div class="section">
    <h2>Upload Chart Screenshot</h2>
    <input type="file" id="screenshotInput" accept="image/*">
    <canvas id="imagePreview" width="300" height="150"></canvas>
    <button id="analyzeBtn">Analyze Screenshot</button>
    <div class="result">
      <div id="imgPrediction"></div>
      <div id="imgExplain"></div>
    </div>
  </div>

  <script>
  const API_KEY = "d3t7e59r01qtes8uqkn0"; // ✅ your correct key here
  const CACHE_TTL = 60 * 1000;
  const chartDiv = document.getElementById('chart');
  const predictionEl = document.getElementById('prediction');
  const explainEl = document.getElementById('explain');
  let chart, candleSeries;
  const cache = {};

  function initChart() {
    chart = LightweightCharts.createChart(chartDiv, { width: chartDiv.clientWidth, height: 300 });
    candleSeries = chart.addCandlestickSeries();
  }

  async function getData(symbol) {
    const now = Date.now();
    if (cache[symbol] && now - cache[symbol].time < CACHE_TTL) return cache[symbol].data;

    const map = {
      "EURUSD": { symbol: "OANDA:EUR_USD", type: "forex" },
      "GBPUSD": { symbol: "OANDA:GBP_USD", type: "forex" },
      "USDJPY": { symbol: "OANDA:USD_JPY", type: "forex" },
      "XAUUSD": { symbol: "OANDA:XAU_USD", type: "forex" },
      "BTCUSD": { symbol: "BINANCE:BTCUSDT", type: "crypto" }
    };

    const pair = map[symbol];
    if (!pair) throw new Error("Symbol not supported or unavailable.");

    const endpoint = pair.type === "crypto" ? "crypto/candle" : "forex/candle";
    const url = `https://finnhub.io/api/v1/${endpoint}?symbol=${pair.symbol}&resolution=1&count=200&token=${API_KEY}`;

    const res = await fetch(url);
    const json = await res.json();

    if (!json || !json.c || json.s !== "ok") {
      throw new Error("⚠️ No data returned. Check API key or symbol format.");
    }

    const data = json.t.map((t, i) => ({
      time: t,
      open: json.o[i],
      high: json.h[i],
      low: json.l[i],
      close: json.c[i]
    }));

    cache[symbol] = { data, time: now };
    return data;
  }

  function calcRSI(data, period = 14) {
    if (data.length < period + 1) return 50;
    let gains = 0, losses = 0;
    for (let i = 1; i <= period; i++) {
      const diff = data[i].close - data[i - 1].close;
      if (diff >= 0) gains += diff; else losses += Math.abs(diff);
    }
    const avgGain = gains / period;
    const avgLoss = losses / period || 0.0001;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }

  function calcMACD(data, short = 12, long = 26, signal = 9) {
    if (data.length < long + signal) return 0;
    function EMA(data, period) {
      const k = 2 / (period + 1);
      let ema = data[0].close;
      return data.map(v => {
        ema = v.close * k + ema * (1 - k);
        return { time: v.time, value: ema };
      });
    }
    const ema12 = EMA(data.slice(-long), short);
    const ema26 = EMA(data.slice(-long), long);
    const macdLine = ema12.map((v, i) => ({ time: v.time, value: v.value - ema26[i].value }));
    const signalLine = EMA(macdLine, signal);
    return macdLine.at(-1).value - signalLine.at(-1).value;
  }

  async function predict(symbol) {
    predictionEl.textContent = "Fetching data...";
    predictionEl.className = "loading";
    explainEl.textContent = "";
    try {
      const data = await getData(symbol);
      candleSeries.setData(data);
      const rsi = calcRSI(data);
      const macd = calcMACD(data);
      const last = data.at(-1);
      const prev = data.at(-2);
      const trend = last.close > prev.close ? 1 : -1;
      let score = (trend * 0.4) + ((macd > 0 ? 1 : -1) * 0.3) + ((rsi > 50 ? 1 : -1) * 0.3);
      const direction = score > 0 ? "UP" : "DOWN";
      const confidence = Math.round(Math.min(100, Math.abs(score) * 100));
      const explain = `RSI ${rsi.toFixed(1)}, MACD ${macd.toFixed(3)} — Predicting ${direction} candle next`;
      predictionEl.textContent = direction + " (" + confidence + "%)";
      predictionEl.className = "pred-badge " + (direction === "UP" ? "up" : "down");
      explainEl.textContent = explain;
    } catch (err) {
      predictionEl.textContent = err.message;
      predictionEl.className = "pred-badge down";
    }
  }

  document.getElementById("fetchData").addEventListener("click", () => {
    const symbol = document.getElementById("symbol").value;
    predict(symbol);
  });

  initChart();

  /* ==== Screenshot Analyzer ==== */
  const screenshotInput = document.getElementById("screenshotInput");
  const imagePreview = document.getElementById("imagePreview");
  const analyzeBtn = document.getElementById("analyzeBtn");
  const imgPrediction = document.getElementById("imgPrediction");
  const imgExplain = document.getElementById("imgExplain");
  let lastUploadedImage = null;

  screenshotInput.addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const ctx = imagePreview.getContext("2d");
        ctx.clearRect(0, 0, imagePreview.width, imagePreview.height);
        ctx.drawImage(img, 0, 0, imagePreview.width, imagePreview.height);
        lastUploadedImage = img;
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });

  analyzeBtn.addEventListener("click", async () => {
    if (!lastUploadedImage) {
      alert("Please upload a screenshot first.");
      return;
    }
    imgPrediction.textContent = "Analyzing...";
    try {
      const tensor = tf.browser.fromPixels(lastUploadedImage)
        .resizeBilinear([64, 64])
        .mean(2)
        .expandDims(0)
        .expandDims(-1)
        .div(255);
      const mean = (await tensor.mean().array());
      const dir = mean > 0.5 ? "DOWN" : "UP";
      const confidence = Math.round(Math.abs(0.5 - mean) * 200);
      const explain = `Brightness: ${mean.toFixed(2)} — likely ${dir}`;
      imgPrediction.textContent = dir + " (" + confidence + "%)";
      imgPrediction.className = "pred-badge " + (dir === "UP" ? "up" : "down");
      imgExplain.textContent = explain;
    } catch (err) {
      imgPrediction.textContent = "Error analyzing image.";
      imgExplain.textContent = err.message;
    }
  });
  </script>
</body>
</html>
