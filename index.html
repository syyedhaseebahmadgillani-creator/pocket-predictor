<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pocket Option Predictor Bot</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: #0f172a;
      color: #f1f5f9;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    header {
      background: linear-gradient(135deg, #10b981, #0284c7);
      color: white;
      padding: 16px;
      font-size: 24px;
      font-weight: bold;
    }
    .container {
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
    }
    select, button {
      padding: 10px;
      font-size: 16px;
      margin: 5px;
      border: none;
      border-radius: 8px;
    }
    select { width: 60%; }
    button {
      background: #10b981;
      color: white;
      cursor: pointer;
    }
    button:hover { background: #059669; }
    .card {
      background: #1e293b;
      padding: 16px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }
    canvas { width: 100%; height: 300px; margin-top: 10px; }
    .prediction {
      font-size: 18px;
      margin-top: 12px;
    }
    .pred-badge {
      font-weight: bold;
      font-size: 24px;
      color: #10b981;
    }
    .muted {
      font-size: 14px;
      color: #94a3b8;
    }
  </style>
</head>
<body>
  <header>ðŸ“Š Pocket Option Prediction Bot</header>
  <div class="container">
    <p>Select a currency or commodity pair to predict the next candle move.</p>

    <select id="symbol">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="USDCAD">USD/CAD</option>
      <option value="AUDUSD">AUD/USD</option>
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="XAGUSD">Silver (XAG/USD)</option>
      <option value="WTICOUSD">Crude Oil (WTI/USD)</option>
      <option value="BTCUSD">Bitcoin (BTC/USD)</option>
      <option value="ETHUSD">Ethereum (ETH/USD)</option>
    </select>
    <br>
    <button onclick="fetchPrediction()">ðŸ”® Predict</button>

    <div class="card">
      <canvas id="chart"></canvas>
      <div class="prediction">
        <div id="direction" class="pred-badge">â€”</div>
        <div class="muted" id="confidence">Confidence: â€”</div>
        <div class="muted" id="countdown">Countdown: â€”</div>
        <div class="muted" id="last-update">Last update: â€”</div>
      </div>
    </div>

    <!-- Screenshot Upload Section -->
    <div class="card" style="margin-top:16px; text-align:center;">
      <h3 style="color:#10b981;">Upload Chart Screenshot (Optional)</h3>
      <input type="file" accept="image/*" id="chartUpload" onchange="showImage(event)" />
      <div id="imagePreview" style="margin-top:10px;"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const ALPHA_VANTAGE_KEY = 'EE28K6YNF9TZFDKA'; // âœ… Your API Key
    let chartInstance;

    async function fetchPrediction() {
      const symbol = document.getElementById('symbol').value;
      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=${symbol}&interval=1min&apikey=${ALPHA_VANTAGE_KEY}`;
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        const timeSeries = data['Time Series (1min)'];

        if (!timeSeries) {
          alert("API limit reached or invalid response. Try again later.");
          return;
        }

        const times = Object.keys(timeSeries).slice(0, 20).reverse();
        const closes = times.map(t => parseFloat(timeSeries[t]['4. close']));

        // Update chart
        const ctx = document.getElementById('chart').getContext('2d');
        if (chartInstance) chartInstance.destroy();
        chartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: times,
            datasets: [{
              label: `${symbol} Price`,
              data: closes,
              borderColor: '#10b981',
              tension: 0.3
            }]
          },
          options: { plugins: { legend: { display: false } } }
        });

        // Basic Prediction
        const last = closes[closes.length - 1];
        const prev = closes[closes.length - 2];
        let direction = '';
        let confidence = 0;

        if (last > prev) { direction = 'Next Candle â†“ (Likely Bearish)'; confidence = 65; }
        else if (last < prev) { direction = 'Next Candle â†‘ (Likely Bullish)'; confidence = 70; }
        else { direction = 'Sideways / No Clear Signal'; confidence = 50; }

        document.getElementById('direction').innerText = direction;
        document.getElementById('confidence').innerText = `Confidence: ${confidence}%`;
        document.getElementById('last-update').innerText = `Last update: ${new Date().toLocaleTimeString()}`;
        
        startCountdown(60); // 1-min countdown for next candle

      } catch (error) {
        console.error(error);
        alert("Error fetching data. Check your internet or API key.");
      }
    }

    function startCountdown(seconds) {
      const el = document.getElementById('countdown');
      let remaining = seconds;
      const timer = setInterval(() => {
        el.innerText = `Countdown: ${remaining}s`;
        remaining--;
        if (remaining < 0) clearInterval(timer);
      }, 1000);
    }

    /* ======== Screenshot Preview ======== */
    function showImage(event){
      const file = event.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e){
        document.getElementById('imagePreview').innerHTML =
          `<img src="${e.target.result}" alt="Uploaded Chart" 
          style="max-width:95%;border-radius:8px;border:2px solid #10b981;margin-top:10px;">`;
      };
      reader.readAsDataURL(file);
    }
  </script>
</body>
</html>
