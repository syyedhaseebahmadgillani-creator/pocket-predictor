<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Pocket Option — Advanced Predictor</title>

  <style>
    :root{
      --bg:#071024; --card:#0b1220; --accent:#10b981; --muted:#94a3b8; --glass: rgba(255,255,255,0.03);
    }
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#071024,#071725);color:#e6eef7;min-height:100vh;}
    .wrap{max-width:980px;margin:18px auto;padding:16px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;}
    h1{font-size:18px;margin:0;color:var(--accent)}
    .muted{color:var(--muted);font-size:13px}
    .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6);margin-top:12px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    select,input,button{background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px;border-radius:8px}
    button{cursor:pointer}
    #chart{height:380px;border-radius:8px;overflow:hidden}
    .prediction{margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .pred-badge{padding:10px 16px;border-radius:10px;font-weight:700}
    .pred-up{background:linear-gradient(90deg,rgba(16,185,129,0.12),rgba(16,185,129,0.06));color:#86f0c9}
    .pred-down{background:linear-gradient(90deg,rgba(239,68,68,0.06),rgba(239,68,68,0.02));color:#ffb3b3}
    .small{font-size:13px;color:var(--muted)}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:4px}
    .col{display:flex;flex-direction:column}
    .row{display:flex;gap:8px;align-items:center;}
    .half{flex:1}
    .image-preview img{max-width:100%;border-radius:8px;border:2px solid #0b7a53}
    @media(max-width:700px){ .controls{flex-direction:column} }
  </style>

  <!-- Lightweight charts -->
  <script src="https://unpkg.com/lightweight-charts@4.1.6/dist/lightweight-charts.standalone.production.js"></script>
  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Pocket Option — Advanced Candle Predictor</h1>
        <div class="small">EMA / RSI / MACD rule-based predictor + optional TF visual assist</div>
      </div>
      <div class="small">Free demo • Client-only (GitHub Pages)</div>
    </header>

    <!-- Controls -->
    <div class="card">
      <div class="controls">
        <div class="col" style="min-width:160px">
          <label for="symbol">Asset</label>
          <select id="symbol"></select>
        </div>

        <div class="col" style="width:120px">
          <label for="interval">Timeframe</label>
          <select id="interval">
            <option value="1min">1m</option>
            <option value="5min">5m</option>
            <option value="15min">15m</option>
            <option value="30min">30m</option>
            <option value="60min">60m</option>
          </select>
        </div>

        <div class="col" style="width:140px">
          <label for="target">Predict</label>
          <select id="target">
            <option value="current">Current candle</option>
            <option value="next">Next candle</option>
          </select>
        </div>

        <div class="col" style="width:140px">
          <label for="expiry">Expiry (seconds)</label>
          <input id="expiry" type="number" value="60" min="5" step="5" />
        </div>

        <div class="row" style="margin-left:auto">
          <button id="refresh">Refresh</button>
          <button id="start">Start Auto</button>
        </div>
      </div>
    </div>

    <!-- Chart card -->
    <div class="card">
      <div id="chart"></div>

      <div class="prediction">
        <div id="direction" class="pred-badge">—</div>
        <div class="small" id="confidence">Confidence: —</div>
        <div class="small" id="countdown">Countdown: —</div>
        <div class="small" id="last-update">Last update: —</div>
      </div>
      <div class="small" id="explain" style="margin-top:8px"></div>
    </div>

    <!-- Screenshot upload & visual analysis -->
    <div class="card">
      <h3 style="margin:0 0 8px 0;color:var(--accent)">Upload Chart Screenshot (optional)</h3>
      <div class="controls">
        <div class="col half">
          <label for="screenshot">Upload image</label>
          <input type="file" id="screenshot" accept="image/*" />
          <div class="small" style="margin-top:6px">The visual analyzer extracts simple features and gives an auxiliary prediction (heuristic).</div>
        </div>

        <div class="col" style="min-width:160px">
          <label>&nbsp;</label>
          <button id="analyzeVisual">Analyze Visual</button>
        </div>

        <div class="col" style="min-width:160px">
          <label>&nbsp;</label>
          <div id="visualResult" class="small">Visual: —</div>
        </div>
      </div>

      <div id="imagePreview" class="image-preview" style="margin-top:12px"></div>
    </div>

    <footer style="margin-top:12px" class="small">
      Data source: Alpha Vantage (client-side) — free key inside script. Respect free tier limits (approx 5 requests/minute). Visual analyzer is heuristic; not a trained model.
    </footer>
  </div>

<script>
/* =================== CONFIG =================== */
/* Your provided Alpha Vantage key */
const ALPHA_VANTAGE_KEY = 'EE28K6YNF9TZFDKA';
/* tuning */
const RATE_LIMIT_MAX_PER_MIN = 5; // avoid exceeding 5 calls/min
/* default symbol list (editable) */
const SYMBOLS = [
  'EURUSD','GBPUSD','USDJPY','USDCHF','AUDUSD','USDCAD','NZDUSD','GBPJPY',
  'XAUUSD','XAGUSD','BTCUSD','ETHUSD','AAPL','TSLA','MSFT'
];
/* caching TTLs (ms) depending on timeframe */
const TTL_MAP = { '1min': 12*1000, '5min': 30*1000, '15min': 60*1000, '30min': 90*1000, '60min': 150*1000 };

/* =================== UI refs =================== */
const symbolSelect = document.getElementById('symbol');
const intervalInput = document.getElementById('interval');
const targetInput = document.getElementById('target');
const expiryInput = document.getElementById('expiry');
const refreshBtn = document.getElementById('refresh');
const startBtn = document.getElementById('start');
const directionEl = document.getElementById('direction');
const confidenceEl = document.getElementById('confidence');
const countdownEl = document.getElementById('countdown');
const lastUpdateEl = document.getElementById('last-update');
const explainEl = document.getElementById('explain');
const visualResultEl = document.getElementById('visualResult');
const analyzeVisualBtn = document.getElementById('analyzeVisual');
const screenshotInput = document.getElementById('screenshot');
const imagePreview = document.getElementById('imagePreview');

/* populate symbols */
SYMBOLS.forEach(s=>{
  const opt = document.createElement('option');
  opt.value = s; opt.textContent = s;
  symbolSelect.appendChild(opt);
});

/* =================== Chart (Lightweight Charts) =================== */
let chart, candleSeries;
function createChart(){
  const container = document.getElementById('chart');
  container.innerHTML = '';
  chart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#071025' }, textColor: '#dbeafe' },
    rightPriceScale: { visible: true },
    timeScale: { timeVisible: true, secondsVisible: false },
    grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
    localization: { dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm' }
  });
  candleSeries = chart.addCandlestickSeries();
}
createChart();

/* =================== UTIL: localStorage-based rate limiter & cache =================== */

function getCallRecords(){
  try{
    const raw = localStorage.getItem('av_call_times');
    return raw ? JSON.parse(raw) : [];
  }catch(e){ return []; }
}
function pushCallRecord(ts){
  const rec = getCallRecords().filter(t=> t > Date.now() - 61*1000);
  rec.push(ts);
  localStorage.setItem('av_call_times', JSON.stringify(rec));
}
function callsInLastMinute(){
  return getCallRecords().filter(t=> t > Date.now() - 61*1000).length;
}

/* cache helpers */
function cacheKey(symbol, interval){ return `candles_${symbol}_${interval}`; }
function putCache(symbol, interval, data){
  const key = cacheKey(symbol, interval);
  const payload = { ts: Date.now(), data };
  try{ localStorage.setItem(key, JSON.stringify(payload)); }catch(e){}
}
function getCache(symbol, interval){
  try{
    const key = cacheKey(symbol, interval);
    const raw = localStorage.getItem(key);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    const ttl = TTL_MAP[interval] || 15000;
    if(Date.now() - parsed.ts > ttl) return null;
    return parsed.data;
  }catch(e){ return null; }
}

/* =================== Alpha Vantage fetch with throttling + fallbacks =================== */
async function fetchCandlesAlphaVantage(symbol, interval){
  // Check cache first
  const cached = getCache(symbol, interval);
  if(cached) return cached;

  // Prevent exceeding rate limit
  if(callsInLastMinute() >= RATE_LIMIT_MAX_PER_MIN){
    // use stale cache if any (older than TTL) to avoid blocking
    const rawKey = cacheKey(symbol, interval);
    try{
      const raw = localStorage.getItem(rawKey);
      if(raw){
        const parsed = JSON.parse(raw);
        // return stale but usable data with a warning
        explainEl.textContent = 'Note: rate limit reached — using recently cached data.';
        return parsed.data;
      }
    }catch(e){}
    throw new Error('Rate limit reached (no cached data available). Wait a bit.');
  }

  // Attempt FX_INTRADAY for forex-like symbols
  const from = symbol.slice(0,3), to = symbol.slice(3);
  let urlFx = `https://www.alphavantage.co/query?function=FX_INTRADAY&from_symbol=${from}&to_symbol=${to}&interval=${interval}&outputsize=compact&apikey=${ALPHA_VANTAGE_KEY}`;
  try{
    pushCallRecord(Date.now());
    const r = await fetch(urlFx);
    const j = await r.json();
    if(j['Note']) throw new Error(j['Note']);
    // parse
    const parsed = parseAlphaVantageIntraday(j);
    if(parsed && parsed.length){
      putCache(symbol, interval, parsed);
      return parsed;
    }
  }catch(err){
    // continue to stock fallback
  }

  // Try stock/time series intraday
  const urlStock = `https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=${symbol}&interval=${interval}&outputsize=compact&apikey=${ALPHA_VANTAGE_KEY}`;
  try{
    pushCallRecord(Date.now());
    const r2 = await fetch(urlStock);
    const j2 = await r2.json();
    if(j2['Note']) throw new Error(j2['Note']);
    const parsed2 = parseAlphaVantageIntraday(j2);
    if(parsed2 && parsed2.length){
      putCache(symbol, interval, parsed2);
      return parsed2;
    }
  }catch(err2){ /* final */ }

  // final: no data
  throw new Error('No data returned from provider for ' + symbol);
}

function parseAlphaVantageIntraday(json){
  const key = Object.keys(json).find(k=>k.toLowerCase().includes('time series'));
  if(!key) return null;
  const series = json[key];
  const out = [];
  for(const time in series){
    const d = series[time];
    out.push({
      time: time,
      open: parseFloat(d['1. open']),
      high: parseFloat(d['2. high']),
      low: parseFloat(d['3. low']),
      close: parseFloat(d['4. close']),
      volume: parseFloat(d['5. volume'] || 0)
    });
  }
  out.sort((a,b)=> new Date(a.time) - new Date(b.time));
  return out;
}

/* =================== Technical indicators: EMA, RSI, MACD =================== */
function emaArray(values, period){
  const out = [];
  const k = 2/(period+1);
  if(values.length < period){
    return out;
  }
  // simple SMA for first
  let prev = values.slice(0,period).reduce((a,b)=>a+b,0)/period;
  out[period-1] = prev;
  for(let i=period;i<values.length;i++){
    prev = values[i]*k + prev*(1-k);
    out[i] = prev;
  }
  return out;
}
function ema(values, period){
  const arr = emaArray(values, period);
  return arr.length ? arr[arr.length-1] : null;
}

function computeRSI(closes, period=14){
  if(closes.length < period+1) return null;
  let gains=0, losses=0;
  for(let i=1;i<=period;i++){
    const d = closes[closes.length - 1 - (period - i)];
    const prev = closes[closes.length - 2 - (period - i)];
    const diff = d - prev;
    if(diff>0) gains += diff; else losses += Math.abs(diff);
  }
  let avgGain = gains/period;
  let avgLoss = losses/period;
  if(avgLoss === 0) return 100;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}

function computeMACD(closes, fast=12, slow=26, signal=9){
  if(closes.length < slow + signal) return null;
  // compute EMAs arrays
  const emaFastArr = emaArray(closes, fast);
  const emaSlowArr = emaArray(closes, slow);
  // align
  const macd = [];
  for(let i=0;i<closes.length;i++){
    if(emaFastArr[i] && emaSlowArr[i]) macd[i] = emaFastArr[i] - emaSlowArr[i];
  }
  const signalArr = emaArray(macd.filter(v=>v!==undefined), signal); // approximate
  const lastMacd = macd[macd.length-1];
  const lastSignal = signalArr[signalArr.length-1];
  if(lastMacd===undefined || lastSignal===undefined) return null;
  return { macd: lastMacd, signal: lastSignal, hist: lastMacd - lastSignal };
}

/* =================== Prediction scoring combining indicators =================== */
function computePredictionScore(candles, target){
  if(!candles || candles.length < 30) return {dir:'—',confidence:0,explain:'insufficient data'};

  const closes = candles.map(c=>c.close);
  const emaShortVal = ema(closes, 8);
  const emaLongVal = ema(closes, 21);
  const rsi = computeRSI(closes, 14);
  const macdObj = computeMACD(closes, 12, 26, 9);

  const last = candles[candles.length-1];
  const prev = candles[candles.length-2];

  // base score from EMA crossover
  let score = 50;
  let dir = '—';
  if(emaShortVal && emaLongVal){
    if(emaShortVal > emaLongVal){ dir = 'UP'; score += 12; }
    else if(emaShortVal < emaLongVal){ dir = 'DOWN'; score -= 12; }
  }

  // RSI adds/subtracts
  if(rsi !== null){
    if(rsi < 30) { score += 10; if(dir==='DOWN') score += 5; }        // oversold -> bullish
    else if(rsi > 70) { score -= 10; if(dir==='UP') score -= 5; }   // overbought -> bearish
  }

  // MACD histogram
  if(macdObj){
    if(macdObj.hist > 0) score += Math.min(10, macdObj.hist * 50);
    else score -= Math.min(10, Math.abs(macdObj.hist) * 50);
  }

  // last candle momentum
  const momentum = last.close - prev.close;
  if(momentum > 0) score += Math.min(8, momentum / prev.close * 100);
  else score -= Math.min(8, Math.abs(momentum) / prev.close * 100);

  // target uncertainty
  if(target === 'next') score *= 0.94;

  // normalize
  const conf = Math.max(1, Math.min(99, Math.round(Math.abs(score))));
  const finalDir = score >= 50 ? 'UP' : 'DOWN';
  const explain = `EMA8:${emaShortVal?emaShortVal.toFixed(5):'n/a'} EMA21:${emaLongVal?emaLongVal.toFixed(5):'n/a'} RSI:${rsi?rsi.toFixed(1):'n/a'} MACD_hist:${macdObj?macdObj.hist.toFixed(4):'n/a'}`;
  return { dir: finalDir, confidence: conf, explain };
}

/* =================== Countdown handling =================== */
let countdownInterval = null;
function updateCountdown(candles, target){
  if(countdownInterval) clearInterval(countdownInterval);
  function tick(){
    const interval = intervalInput.value;
    const last = candles[candles.length-1];
    const secs = parseInt(interval.replace('min',''))*60;
    const lastTime = new Date(last.time.replace(' ', 'T'));
    const nextClose = new Date(lastTime.getTime() + secs*1000);
    const now = new Date();
    let remainingMs = (target === 'current') ? (nextClose - now) : (nextClose.getTime() + secs*1000 - now.getTime());
    if(remainingMs < 0) remainingMs = 0;
    const s = Math.floor(remainingMs/1000);
    countdownEl.textContent = `Countdown: ${s}s`;
  }
  tick();
  countdownInterval = setInterval(tick, 500);
}

/* =================== Main refresh & show =================== */
async function refreshAndPredict(){
  try{
    explainEl.textContent = '';
    const symbol = symbolSelect.value;
    const interval = intervalInput.value;
    const target = targetInput.value;

    lastUpdateEl.textContent = `Last update: ${new Date().toLocaleTimeString()}`;
    // fetch candles (with caching & throttling)
    const candles = await fetchCandlesAlphaVantage(symbol, interval);
    if(!candles || candles.length===0) throw new Error('No candles');

    // update chart data
    const chartData = candles.map(c=>({
      time: c.time.replace(' ', 'T'),
      open: c.open, high: c.high, low: c.low, close: c.close
    }));
    candleSeries.setData(chartData);

    // compute technical prediction
    const pred = computePredictionScore(candles, target);
    showPrediction(pred);

    // update countdown
    updateCountdown(candles, target);

  }catch(err){
    alert('Error: ' + (err.message||err));
    console.error(err);
  }
}

function showPrediction(pred){
  directionEl.className = 'pred-badge';
  if(pred.dir === 'UP'){ directionEl.classList.add('pred-up'); directionEl.textContent = 'UP ▲'; }
  else { directionEl.classList.add('pred-down'); directionEl.textContent = 'DOWN ▼'; }
  confidenceEl.textContent = `Confidence: ${pred.confidence}%`;
  explainEl.textContent = pred.explain;
}

/* =================== Auto refresh control =================== */
let autoInterval = null;
refreshBtn.addEventListener('click', ()=> refreshAndPredict());
startBtn.addEventListener('click', ()=>{
  if(autoInterval){
    clearInterval(autoInterval);
    autoInterval = null;
    startBtn.textContent = 'Start Auto';
  } else {
    const sec = Math.max(10, parseInt(expiryInput.value,10) || 60);
    autoInterval = setInterval(refreshAndPredict, sec*1000);
    startBtn.textContent = 'Stop Auto';
    refreshAndPredict();
  }
});

/* =================== Visual analysis (tfjs heuristic) =================== */
/* The visual analyzer extracts simple features from the uploaded image:
   - overall brightness slope (left->right)
   - edge density (Canny-like via sobel)
   - vertical/horizontal intensity ratio
   These numeric features are fed into a small tfjs inference dense layer with preset weights to produce a visual score.
   NOTE: this is a heuristic wrapped in tfjs. For real ML, replace with a trained model and load via tf.loadLayersModel(url).
*/

function drawImageToCanvas(img){
  const canvas = document.createElement('canvas');
  const maxW = 600;
  const scale = Math.min(1, maxW / img.width);
  canvas.width = Math.round(img.width * scale);
  canvas.height = Math.round(img.height * scale);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}

function extractImageFeatures(img){
  // returns [brightnessSlope, edgeDensity, vertHorizRatio]
  const canvas = drawImageToCanvas(img);
  const ctx = canvas.getContext('2d');
  const { width, height } = canvas;
  const imageData = ctx.getImageData(0,0,width,height);
  const data = imageData.data;
  // brightness map and basic sobel
  const gray = new Float32Array(width*height);
  for(let i=0;i<width*height;i++){
    const r = data[i*4], g=data[i*4+1], b=data[i*4+2];
    gray[i] = 0.299*r + 0.587*g + 0.114*b;
  }
  // compute brightness slope L->R: average brightness each column, then slope
  const colAvg = new Float32Array(width);
  for(let x=0;x<width;x++){
    let sum=0;
    for(let y=0;y<height;y++) sum += gray[y*width + x];
    colAvg[x] = sum/height;
  }
  // slope via linear regression
  let sx=0, sy=0, sxx=0, sxy=0;
  for(let x=0;x<width;x++){
    sx += x; sy += colAvg[x]; sxx += x*x; sxy += x*colAvg[x];
  }
  const slope = (width * sxy - sx*sy) / (width * sxx - sx*sx + 1e-9);
  // simple sobel edge magnitude
  let edgesSum = 0;
  for(let y=1;y<height-1;y++){
    for(let x=1;x<width-1;x++){
      const idx = y*width + x;
      const gx = - gray[idx-width-1] -2*gray[idx-1] - gray[idx+width-1] + gray[idx-width+1] + 2*gray[idx+1] + gray[idx+width+1];
      const gy = - gray[idx-width-1] -2*gray[idx-width] - gray[idx-width+1] + gray[idx+width-1] + 2*gray[idx+width] + gray[idx+width+1];
      const mag = Math.sqrt(gx*gx + gy*gy);
      edgesSum += mag;
    }
  }
  const edgeDensity = edgesSum / (width*height);
  // vertical vs horizontal contrast: compare average top half vs left half
  let topSum=0, leftSum=0;
  for(let y=0;y<Math.floor(height/2);y++){
    for(let x=0;x<width;x++) topSum += gray[y*width+x];
  }
  for(let y=0;y<height;y++){
    for(let x=0;x<Math.floor(width/2);x++) leftSum += gray[y*width+x];
  }
  const topAvg = topSum / (Math.floor(height/2)*width + 1e-9);
  const leftAvg = leftSum / (height*Math.floor(width/2) + 1e-9);
  const vertHorizRatio = (topAvg+1)/(leftAvg+1);

  return { slope, edgeDensity, vertHorizRatio, canvas };
}

async function visualPredictFromImage(img){
  // feature extraction
  const f = extractImageFeatures(img);
  // normalize features to reasonable ranges (heuristic)
  const feat = [
    f.slope * 0.01,                // small scale
    Math.tanh(f.edgeDensity*0.02), // bounded
    (f.vertHorizRatio - 1) * 0.5   // centered
  ];
  // create tf tensors
  const x = tf.tensor2d([feat]); // shape [1,3]

  // Heuristic weights and bias (preset)
  // We'll compute w*x + b then sigmoid to get [0..1]
  // weights shaped [3,1]
  const W = tf.tensor2d([[2.2],[ -1.4 ],[ 0.8 ]]); // chosen heuristics
  const b = tf.scalar(0.05);

  // prediction score (0..1) where >0.5 => UP signal from image
  const y = tf.tidy(()=> x.matMul(W).add(b).sigmoid().dataSync()[0] );
  x.dispose(); W.dispose(); b.dispose();
  // convert into direction + confidence
  const dir = y >= 0.5 ? 'UP' : 'DOWN';
  const confidence = Math.round(y*100);
  return { dir, confidence, features: feat, canvas: f.canvas };
}

/* =================== File input and visual analyze handlers =================== */
let lastUploadedImage = null;
screenshotInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    imagePreview.innerHTML = '';
    imagePreview.appendChild(img);
    lastUploadedImage = img;
  };
  img.src = url;
});

analyzeVisualBtn.addEventListener('click', async ()=>{
  if(!lastUploadedImage){
    visualResultEl.textContent = 'Visual: upload an image first.';
    return;
  }
  visualResultEl.textContent = 'Visual: analyzing...';
  try{
    const v = await visualPredictFromImage(lastUploadedImage);
    visualResultEl.textContent = `Visual: ${v.dir} • ${v.confidence}% (heuristic)`;
    // show processed canvas under preview if exists
    const cv = v.canvas;
    if(cv){
      // replace preview with canvas for clarity
      imagePreview.innerHTML = '';
      imagePreview.appendChild(cv);
      cv.style.maxWidth = '100%';
      cv.style.borderRadius = '8px';
      cv.style.border = '2px solid #10b981';
    }
  }catch(err){
    console.error(err);
    visualResultEl.textContent = 'Visual: analysis failed.';
  }
});

/* =================== Startup: set defaults and initial refresh =================== */
refreshAndPredict(); // initial try

// auto-refresh one-time if page loaded
window.addEventListener('load', ()=> {
  // try initial fetch after slight delay to avoid immediate rate hit
  setTimeout(()=> refreshAndPredict(), 800);
});

/* =================== End of script =================== */
</script>
</body>
</html>
